<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3Dæ¨¡å‹å¡ç‰‡</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .card {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            width: 100%;
            max-width: 400px;
        }

        .card-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }

        .card-title {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .card-subtitle {
            font-size: 14px;
            opacity: 0.9;
        }

        .card-body {
            padding: 20px;
        }

        .model-container {
            width: 100%;
            height: 300px;
            background: #f5f5f5;
            border-radius: 12px;
            overflow: hidden;
            position: relative;
        }

        #model-canvas {
            width: 100%;
            height: 100%;
        }

        .model-info {
            margin-top: 20px;
        }

        .model-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }

        .model-value {
            font-size: 16px;
            font-weight: 600;
            color: #333;
            margin-bottom: 15px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .control-btn {
            flex: 1;
            padding: 12px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .control-btn.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .control-btn.secondary {
            background: #f0f0f0;
            color: #333;
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            transform: translateY(0);
        }

        .file-upload {
            margin-top: 15px;
        }

        .file-upload-label {
            display: block;
            padding: 12px 20px;
            background: #f0f0f0;
            border-radius: 8px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 14px;
            color: #666;
        }

        .file-upload-label:hover {
            background: #e0e0e0;
        }

        #model-file {
            display: none;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #666;
        }

        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #f44336;
            padding: 20px;
        }


    </style>
</head>
<body>
    <div class="card">
        <div class="card-header">
            <div class="card-title">3Dæ¨¡å‹å±•ç¤º</div>
            <div class="card-subtitle">æ”¯æŒ GLB/GLTF æ ¼å¼ï¼ˆç¦»çº¿ç‰ˆï¼‰</div>
        </div>
        <div class="card-body">
            <div class="model-container" id="model-container">
                <canvas id="model-canvas"></canvas>
                <div class="loading" id="loading">
                    <div class="loading-spinner"></div>
                    <div>åˆå§‹åŒ–ä¸­...</div>
                </div>
                <div class="error-message" id="error" style="display: none;"></div>
            </div>

            <div class="model-info">
                <div class="model-label">æ¨¡å‹ç±»å‹</div>
                <div class="model-value" id="model-type">ç«‹æ–¹ä½“</div>

                <div class="model-label">æ¨¡å‹çŠ¶æ€</div>
                <div class="model-value" id="model-status">å°±ç»ª</div>

                <div class="model-label">é¡¶ç‚¹æ•°é‡</div>
                <div class="model-value" id="vertex-count">0</div>

                <div class="model-label">é¢æ•°é‡</div>
                <div class="model-value" id="face-count">0</div>
            </div>

            <div class="file-upload">
                <label class="file-upload-label" for="model-file">
                    ğŸ“ é€‰æ‹©æ¨¡å‹æ–‡ä»¶ (GLB/GLTF)
                </label>
                <input type="file" id="model-file" accept=".glb,.gltf">
            </div>

            <div class="controls">
                <button class="control-btn primary" id="auto-rotate-btn">è‡ªåŠ¨æ—‹è½¬</button>
                <button class="control-btn secondary" id="change-shape-btn">åˆ‡æ¢å½¢çŠ¶</button>
            </div>
        </div>
    </div>

    <!-- Three.js ä»æœ¬åœ°åŠ è½½ -->
    <script src="three.min.js"></script>

    <script>
        // æ£€æŸ¥ Three.js æ˜¯å¦åŠ è½½æˆåŠŸ
        if (typeof THREE === 'undefined') {
            alert('Three.js æœªåŠ è½½ï¼è¯·ç¡®ä¿ three.min.js æ–‡ä»¶åœ¨å½“å‰ç›®å½•ä¸­ã€‚');
        }

        // å…¨å±€å˜é‡
        let scene, camera, renderer, controls, model;
        let autoRotate = false;
        const loadingElement = document.getElementById('loading');
        const errorElement = document.getElementById('error');
        const canvas = document.getElementById('model-canvas');
        const container = document.getElementById('model-container');

        // åŠ¨æ€åŠ è½½æ’ä»¶
        let GLTFLoader = null;
        let OrbitControls = null;

        function loadPlugins() {
            const promises = [];

            // åŠ è½½ GLTFLoader
            if (typeof THREE.GLTFLoader === 'undefined') {
                promises.push(
                    new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'GLTFLoader.js';
                        script.onload = () => {
                            GLTFLoader = THREE.GLTFLoader;
                            resolve();
                        };
                        script.onerror = () => reject('GLTFLoader åŠ è½½å¤±è´¥');
                        document.head.appendChild(script);
                    })
                );
            } else {
                GLTFLoader = THREE.GLTFLoader;
            }

            // åŠ è½½ OrbitControls
            if (typeof THREE.OrbitControls === 'undefined') {
                promises.push(
                    new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = 'OrbitControls.js';
                        script.onload = () => {
                            OrbitControls = THREE.OrbitControls;
                            resolve();
                        };
                        script.onerror = () => reject('OrbitControls åŠ è½½å¤±è´¥');
                        document.head.appendChild(script);
                    })
                );
            } else {
                OrbitControls = THREE.OrbitControls;
            }

            return Promise.all(promises);
        }

        // ç®€åŒ–çš„ OrbitControls å®ç°ï¼ˆå¤‡ç”¨ï¼‰
        class SimpleOrbitControls {
            constructor(camera, domElement) {
                this.camera = camera;
                this.domElement = domElement;
                this.target = new THREE.Vector3(0, 0.75, 0);
                this.enableDamping = true;
                this.dampingFactor = 0.05;
                this.enableZoom = true;
                this.autoRotate = false;

                this.spherical = new THREE.Spherical();
                this.sphericalDelta = new THREE.Spherical();

                this.rotateSpeed = 1.0;
                this.zoomSpeed = 1.2;
                this.panSpeed = 1.0;

                this.minDistance = 0.5;
                this.maxDistance = 100;

                this.isMouseDown = false;
                this.mouseDownX = 0;
                this.mouseDownY = 0;

                // åˆå§‹åŒ– spherical
                const offset = new THREE.Vector3();
                offset.copy(this.camera.position).sub(this.target);
                this.spherical.setFromVector3(offset);

                this.bindEvents();
            }

            bindEvents() {
                const element = this.domElement;

                element.addEventListener('mousedown', (e) => this.onMouseDown(e));
                element.addEventListener('mousemove', (e) => this.onMouseMove(e));
                element.addEventListener('mouseup', () => this.onMouseUp());
                element.addEventListener('mouseleave', () => this.onMouseUp());
                element.addEventListener('wheel', (e) => this.onMouseWheel(e), { passive: false });

                element.addEventListener('touchstart', (e) => this.onTouchStart(e), { passive: false });
                element.addEventListener('touchmove', (e) => this.onTouchMove(e), { passive: false });
                element.addEventListener('touchend', () => this.onTouchEnd());
            }

            onMouseDown(e) {
                e.preventDefault();
                this.isMouseDown = true;
                this.mouseDownX = e.clientX;
                this.mouseDownY = e.clientY;
            }

            onMouseMove(e) {
                if (!this.isMouseDown) return;
                e.preventDefault();

                const deltaX = e.clientX - this.mouseDownX;
                const deltaY = e.clientY - this.mouseDownY;

                this.sphericalDelta.theta -= deltaX * 0.01 * this.rotateSpeed;
                this.sphericalDelta.phi -= deltaY * 0.01 * this.rotateSpeed;

                this.mouseDownX = e.clientX;
                this.mouseDownY = e.clientY;
            }

            onMouseUp() {
                this.isMouseDown = false;
            }

            onMouseWheel(e) {
                if (!this.enableZoom) return;
                e.preventDefault();

                const delta = e.deltaY;
                const zoomSpeed = this.zoomSpeed * 0.002;

                if (delta < 0) {
                    this.spherical.radius *= (1 - zoomSpeed);
                } else {
                    this.spherical.radius *= (1 + zoomSpeed);
                }

                this.spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, this.spherical.radius));
            }

            onTouchStart(e) {
                if (e.touches.length === 1) {
                    e.preventDefault();
                    this.isMouseDown = true;
                    this.mouseDownX = e.touches[0].clientX;
                    this.mouseDownY = e.touches[0].clientY;
                } else if (e.touches.length === 2) {
                    e.preventDefault();
                }
            }

            onTouchMove(e) {
                if (!this.isMouseDown || e.touches.length !== 1) return;
                e.preventDefault();

                const deltaX = e.touches[0].clientX - this.mouseDownX;
                const deltaY = e.touches[0].clientY - this.mouseDownY;

                this.sphericalDelta.theta -= deltaX * 0.01 * this.rotateSpeed;
                this.sphericalDelta.phi -= deltaY * 0.01 * this.rotateSpeed;

                this.mouseDownX = e.touches[0].clientX;
                this.mouseDownY = e.touches[0].clientY;
            }

            onTouchEnd() {
                this.isMouseDown = false;
            }

            update() {
                const offset = new THREE.Vector3();

                if (this.enableDamping) {
                    this.spherical.theta += this.sphericalDelta.theta * this.dampingFactor;
                    this.spherical.phi += this.sphericalDelta.phi * this.dampingFactor;

                    this.sphericalDelta.theta *= (1 - this.dampingFactor);
                    this.sphericalDelta.phi *= (1 - this.dampingFactor);
                } else {
                    this.spherical.theta += this.sphericalDelta.theta;
                    this.spherical.phi += this.sphericalDelta.phi;
                    this.sphericalDelta.set(0, 0, 0);
                }

                this.spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, this.spherical.phi));

                offset.setFromSpherical(this.spherical);
                this.camera.position.copy(this.target).add(offset);
                this.camera.lookAt(this.target);
            }

            reset() {
                this.sphericalDelta.set(0, 0, 0);
                this.target.set(0, 0.75, 0);
                const offset = this.camera.position.clone().sub(this.target);
                this.spherical.setFromVector3(offset);
            }
        }

        // ç®€åŒ–çš„ GLTFLoader - åªæ”¯æŒåŸºæœ¬å‡ ä½•ä½“ï¼ˆä¸æ”¯æŒçœŸæ­£çš„ GLB/GLTF åŠ è½½ï¼‰
        function loadDefaultModel() {
            // åˆ›å»ºä¸€ä¸ªç®€å•çš„ç«‹æ–¹ä½“ä½œä¸ºé»˜è®¤æ¨¡å‹
            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const material = new THREE.MeshStandardMaterial({
                color: 0x667eea,
                metalness: 0.3,
                roughness: 0.4
            });
            model = new THREE.Mesh(geometry, material);
            model.position.y = 0.75;
            model.castShadow = true;
            model.receiveShadow = true;
            scene.add(model);

            updateModelInfo(model);
            document.getElementById('model-status').textContent = 'å·²åŠ è½½ï¼ˆé»˜è®¤æ¨¡å‹ï¼‰';
            loadingElement.style.display = 'none';
        }

        // æ›´æ–°æ¨¡å‹ä¿¡æ¯
        function updateModelInfo(model) {
            let vertexCount = 0;
            let faceCount = 0;

            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position;
                    if (positions) {
                        vertexCount += positions.count;
                        if (child.geometry.index) {
                            faceCount += child.geometry.index.count / 3;
                        } else {
                            faceCount += positions.count / 3;
                        }
                    }
                }
            });

            document.getElementById('model-status').textContent = 'å·²åŠ è½½';
            document.getElementById('vertex-count').textContent = vertexCount.toLocaleString();
            document.getElementById('face-count').textContent = Math.round(faceCount).toLocaleString();
        }

        // åˆå§‹åŒ–åœºæ™¯
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5f5f5);

            // åˆ›å»ºç›¸æœº
            const aspect = container.clientWidth / container.clientHeight;
            camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 1000);
            camera.position.set(0, 2, 5);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;

            // åˆ›å»ºæ§åˆ¶å™¨ï¼ˆä¼˜å…ˆä½¿ç”¨åŸç”Ÿ OrbitControlsï¼Œå¦åˆ™ä½¿ç”¨ SimpleOrbitControlsï¼‰
            if (OrbitControls) {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.zoomSpeed = 1.2;
                controls.rotateSpeed = 1.0;
                controls.target.set(0, 0.75, 0);
                controls.autoRotate = false;
            } else {
                controls = new SimpleOrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.enableZoom = true;
                controls.zoomSpeed = 1.2;
                controls.rotateSpeed = 1.0;
                controls.target.set(0, 0.75, 0);
                controls.autoRotate = false;
            }

            // æ·»åŠ ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(5, 10, 7.5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.4);
            directionalLight2.position.set(-5, 5, -5);
            scene.add(directionalLight2);

            // æ·»åŠ åœ°é¢ç½‘æ ¼
            const gridHelper = new THREE.GridHelper(10, 20, 0xcccccc, 0xeeeeee);
            scene.add(gridHelper);

            // åŠ è½½é»˜è®¤ç¤ºä¾‹æ¨¡å‹ï¼ˆç«‹æ–¹ä½“ï¼‰
            loadDefaultModel();

            // å¼€å§‹åŠ¨ç”»å¾ªç¯
            animate();

            // éšè—åŠ è½½çŠ¶æ€
            loadingElement.style.display = 'none';

            // åˆå§‹åŒ–ç‚¹å‡»æ£€æµ‹
            initClickDetection();
        }

        // åˆå§‹åŒ–ç‚¹å‡»æ£€æµ‹
        let raycaster, mouse, clickMarker, hologramPanel, hologramText;
        let currentClickPosition = null;

        function initClickDetection() {
            // åˆ›å»º Raycaster
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // ç›‘å¬ç‚¹å‡»äº‹ä»¶
            canvas.addEventListener('click', onMouseClick);
            canvas.addEventListener('touchend', onTouchEnd);
        }

        function onMouseClick(event) {
            const rect = canvas.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            // æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†å…¨æ¯é¢æ¿çš„ X æŒ‰é’®
            if (hologramText && currentClickPosition) {
                // å°†ç‚¹å‡»ä½ç½®è½¬æ¢ä¸ºå±å¹•åæ ‡
                const screenPos = currentClickPosition.point.clone();
                screenPos.project(camera);

                const x = (screenPos.x * 0.5 + 0.5) * rect.width + rect.left;
                const y = (screenPos.y * -0.5 + 0.5) * rect.height + rect.top;

                // è®¡ç®—æŒ‰é’®ä½ç½®ï¼ˆå³ä¸Šè§’ï¼‰
                const buttonRadius = 10;
                const buttonX = x + 112; // 256/2 - 16
                const buttonY = y - 48; // -64/2 + 16

                const dist = Math.sqrt(
                    Math.pow(event.clientX - buttonX, 2) +
                    Math.pow(event.clientY - buttonY, 2)
                );

                if (dist < buttonRadius * 2) {
                    hideHologramPanel();
                    return;
                }
            }

            // æ‰§è¡Œå°„çº¿æ£€æµ‹
            raycaster.setFromCamera(mouse, camera);

            // æ£€æµ‹ä¸æ¨¡å‹çš„äº¤å‰
            const intersects = raycaster.intersectObject(model, true);

            if (intersects.length > 0) {
                const point = intersects[0].point;
                const normal = intersects[0].face.normal.clone();
                normal.transformDirection(model.matrixWorld);

                currentClickPosition = {
                    point: point.clone(),
                    normal: normal
                };

                addClickMarker(point, normal);
                createHologramPanel(point, normal);
            }
        }

        function onTouchEnd(event) {
            if (event.changedTouches.length > 0) {
                const touch = event.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;

                // æ£€æµ‹æ˜¯å¦ç‚¹å‡»äº†å…¨æ¯é¢æ¿çš„ X æŒ‰é’®
                if (hologramText && currentClickPosition) {
                    const screenPos = currentClickPosition.point.clone();
                    screenPos.project(camera);

                    const x = (screenPos.x * 0.5 + 0.5) * rect.width + rect.left;
                    const y = (screenPos.y * -0.5 + 0.5) * rect.height + rect.top;

                    const buttonRadius = 10;
                    const buttonX = x + 112;
                    const buttonY = y - 48;

                    const dist = Math.sqrt(
                        Math.pow(touch.clientX - buttonX, 2) +
                        Math.pow(touch.clientY - buttonY, 2)
                    );

                    if (dist < buttonRadius * 2) {
                        hideHologramPanel();
                        return;
                    }
                }

                // æ‰§è¡Œå°„çº¿æ£€æµ‹
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(model, true);

                if (intersects.length > 0) {
                    const point = intersects[0].point;
                    const normal = intersects[0].face.normal.clone();
                    normal.transformDirection(model.matrixWorld);

                    currentClickPosition = {
                        point: point.clone(),
                        normal: normal
                    };

                    addClickMarker(point, normal);
                    createHologramPanel(point, normal);
                }
            }
        }

        function addClickMarker(point, normal) {
            // ç§»é™¤æ—§çš„æ ‡è®°å’Œé¢æ¿
            removeClickMarker();

            // åˆ›å»ºæ–°çš„æ ‡è®°ç‚¹ï¼ˆå‘å…‰çƒï¼‰
            const markerGeometry = new THREE.SphereGeometry(0.06, 16, 16);
            const markerMaterial = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                transparent: true,
                opacity: 0.9
            });
            clickMarker = new THREE.Mesh(markerGeometry, markerMaterial);
            clickMarker.position.copy(point);
            scene.add(clickMarker);
        }

        function createHologramPanel(point, normal) {
            // ç§»é™¤æ—§é¢æ¿
            if (hologramPanel) {
                scene.remove(hologramPanel);
                hologramPanel.geometry.dispose();
                hologramPanel.material.dispose();
                hologramPanel = null;
            }

            // åˆ›å»ºå…¨æ¯é¢æ¿ï¼ˆå¹³é¢ï¼‰
            const panelGeometry = new THREE.PlaneGeometry(0.6, 0.4);
            const panelMaterial = new THREE.MeshBasicMaterial({
                color: 0x667eea,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            hologramPanel = new THREE.Mesh(panelGeometry, panelMaterial);

            // å®šä½é¢æ¿åœ¨ç‚¹å‡»ç‚¹ä¸Šæ–¹ï¼Œå¹³è¡Œäºç‚¹å‡»é¢
            const offset = normal.clone().multiplyScalar(0.01); // ç¨å¾®åç¦»è¡¨é¢
            hologramPanel.position.copy(point).add(offset);

            // è®©é¢æ¿æœå‘æ³•çº¿æ–¹å‘
            hologramPanel.lookAt(
                point.clone().add(normal)
            );

            scene.add(hologramPanel);

            // åˆ›å»ºæ–‡å­—æ ‡ç­¾ï¼ˆä½¿ç”¨ CanvasTextureï¼‰
            const textCanvas = document.createElement('canvas');
            textCanvas.width = 256;
            textCanvas.height = 128;
            const ctx = textCanvas.getContext('2d');

            // èƒŒæ™¯ - åŠé€æ˜æ¸å˜
            const gradient = ctx.createLinearGradient(0, 0, 0, 128);
            gradient.addColorStop(0, 'rgba(102, 126, 234, 0.8)');
            gradient.addColorStop(1, 'rgba(118, 75, 162, 0.8)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 256, 128);

            // è¾¹æ¡† - å‘å…‰æ•ˆæœ
            ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
            ctx.lineWidth = 2;
            ctx.strokeRect(2, 2, 252, 124);

            // X å…³é—­æŒ‰é’®èƒŒæ™¯
            ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
            ctx.beginPath();
            ctx.arc(240, 16, 10, 0, Math.PI * 2);
            ctx.fill();

            // X å…³é—­æŒ‰é’®è¾¹æ¡†
            ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(240, 16, 10, 0, Math.PI * 2);
            ctx.stroke();

            // X å…³é—­æŒ‰é’®æ–‡å­—
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('X', 240, 16);

            // æ–‡å­—å†…å®¹
            ctx.font = 'bold 16px Arial';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            const xText = `X: ${point.x.toFixed(2)}`;
            const yText = `Y: ${point.y.toFixed(2)}`;
            const zText = `Z: ${point.z.toFixed(2)}`;

            ctx.fillText(xText, 110, 35);
            ctx.fillText(yText, 110, 65);
            ctx.fillText(zText, 110, 95);

            // åˆ›å»ºçº¹ç†å’Œæè´¨
            const textTexture = new THREE.CanvasTexture(textCanvas);
            const textMaterial = new THREE.SpriteMaterial({
                map: textTexture,
                transparent: true,
                opacity: 0.95,
                depthTest: false
            });

            hologramText = new THREE.Sprite(textMaterial);
            hologramText.scale.set(0.6, 0.3, 1);

            // æ–‡å­—åœ¨é¢æ¿å‰æ–¹
            const textOffset = normal.clone().multiplyScalar(0.001);
            hologramText.position.copy(point).add(textOffset).add(new THREE.Vector3(0, 0.15, 0));

            scene.add(hologramText);
        }

        function removeClickMarker() {
            if (clickMarker) {
                scene.remove(clickMarker);
                clickMarker.geometry.dispose();
                clickMarker.material.dispose();
                clickMarker = null;
            }

            if (hologramPanel) {
                scene.remove(hologramPanel);
                hologramPanel.geometry.dispose();
                hologramPanel.material.dispose();
                hologramPanel = null;
            }

            if (hologramText) {
                scene.remove(hologramText);
                hologramText.material.map.dispose();
                hologramText.material.dispose();
                hologramText = null;
            }

            currentClickPosition = null;
        }

        function hideHologramPanel() {
            removeClickMarker();
        }

        function updateHologramAnimation() {
            if (!hologramPanel || !currentClickPosition) return;

            // å…¨æ¯é¢æ¿é—ªçƒæ•ˆæœ
            const time = Date.now() * 0.003;
            const pulseOpacity = 0.25 + Math.sin(time * 3) * 0.05;
            hologramPanel.material.opacity = pulseOpacity;

            // å…¨æ¯è¾¹ç¼˜æ‰«æçº¿æ•ˆæœ
            const scanLine = (Math.sin(time * 5) + 1) / 2;

            // è®©æ ‡è®°ç‚¹æ—‹è½¬
            if (clickMarker) {
                clickMarker.rotation.y += 0.05;
                clickMarker.scale.setScalar(1 + Math.sin(time * 4) * 0.2);
            }
        }

        // åŠ è½½æ¨¡å‹ - æ”¯æŒçœŸæ­£çš„ GLB/GLTF åŠ è½½
        function loadModel(file) {
            // æ£€æŸ¥ GLTFLoader æ˜¯å¦å¯ç”¨
            if (!GLTFLoader) {
                errorElement.style.display = 'block';
                errorElement.innerHTML = 'GLTFLoader æœªåŠ è½½ï¼<br>è¯·ç¡®ä¿ GLTFLoader.js æ–‡ä»¶åœ¨å½“å‰ç›®å½•ä¸­ã€‚<br><br>æ‚¨å¯ä»¥è¿è¡Œ download-orbit-controls.bat ä¸‹è½½å¿…éœ€çš„æ’ä»¶ã€‚';
                loadingElement.style.display = 'none';
                return;
            }

            const url = URL.createObjectURL(file);
            const loader = new GLTFLoader();

            loadingElement.style.display = 'block';
            errorElement.style.display = 'none';

            loader.load(
                url,
                (gltf) => {
                    // ç§»é™¤æ—§æ¨¡å‹
                    if (model) {
                        scene.remove(model);
                        model = null;
                    }

                    // æ·»åŠ æ–°æ¨¡å‹
                    model = gltf.scene;

                    // è®¡ç®—æ¨¡å‹çš„è¾¹ç•Œæ¡†
                    const box = new THREE.Box3().setFromObject(model);
                    const size = box.getSize(new THREE.Vector3());
                    const center = box.getCenter(new THREE.Vector3());

                    // å±…ä¸­æ¨¡å‹
                    model.position.sub(center);
                    model.position.y = size.y / 2;

                    // è°ƒæ•´ç›¸æœºä½ç½®
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const fov = camera.fov * (Math.PI / 180);
                    let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                    cameraZ *= 2; // é€‚å½“åé€€ä¸€ç‚¹

                    camera.position.set(0, size.y, cameraZ);
                    camera.lookAt(0, size.y / 2, 0);

                    // å¯ç”¨é˜´å½±
                    model.traverse((child) => {
                        if (child.isMesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });

                    scene.add(model);

                    // æ›´æ–°æ¨¡å‹ä¿¡æ¯
                    updateModelInfo(model);
                    document.getElementById('model-status').textContent = 'å·²åŠ è½½ï¼ˆGLB/GLTFï¼‰';
                    document.getElementById('model-type').textContent = 'å¤–éƒ¨æ¨¡å‹';

                    // éšè—åŠ è½½çŠ¶æ€
                    loadingElement.style.display = 'none';

                    // æ¸…ç† URL
                    URL.revokeObjectURL(url);
                },
                (progress) => {
                    const percent = (progress.loaded / progress.total * 100).toFixed(0);
                    loadingElement.innerHTML = `<div class="loading-spinner"></div><div>åŠ è½½ä¸­... ${percent}%</div>`;
                },
                (error) => {
                    console.error('æ¨¡å‹åŠ è½½å¤±è´¥:', error);
                    loadingElement.style.display = 'none';
                    errorElement.style.display = 'block';
                    errorElement.textContent = 'æ¨¡å‹åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿æ–‡ä»¶æ ¼å¼æ­£ç¡®';
                }
            );
        }

        // æ›´æ–°æ¨¡å‹ä¿¡æ¯
        function updateModelInfo(model) {
            let vertexCount = 0;
            let faceCount = 0;

            model.traverse((child) => {
                if (child.isMesh && child.geometry) {
                    const positions = child.geometry.attributes.position;
                    if (positions) {
                        vertexCount += positions.count;
                        if (child.geometry.index) {
                            faceCount += child.geometry.index.count / 3;
                        } else {
                            faceCount += positions.count / 3;
                        }
                    }
                }
            });

            document.getElementById('model-status').textContent = 'å·²åŠ è½½';
            document.getElementById('vertex-count').textContent = vertexCount.toLocaleString();
            document.getElementById('face-count').textContent = Math.round(faceCount).toLocaleString();
        }

        // åˆ‡æ¢å½¢çŠ¶
        const shapes = {
            cube: { name: 'ç«‹æ–¹ä½“', create: () => new THREE.BoxGeometry(1.5, 1.5, 1.5), color: 0x667eea },
            sphere: { name: 'çƒä½“', create: () => new THREE.SphereGeometry(0.75, 32, 32), color: 0x4facfe },
            cone: { name: 'åœ†é”¥', create: () => new THREE.ConeGeometry(0.75, 1.5, 32), color: 0x764ba2 },
            torus: { name: 'åœ†ç¯', create: () => new THREE.TorusGeometry(0.75, 0.2, 16, 100), color: 0x00f2fe }
        };
        const shapeKeys = Object.keys(shapes);
        let currentShapeIndex = 0;

        function changeShape() {
            // ç§»é™¤æ—§æ¨¡å‹
            if (model) {
                scene.remove(model);
                model.geometry.dispose();
                model.material.dispose();
            }

            // è·å–ä¸‹ä¸€ä¸ªå½¢çŠ¶
            currentShapeIndex = (currentShapeIndex + 1) % shapeKeys.length;
            const shape = shapes[shapeKeys[currentShapeIndex]];

            // åˆ›å»ºæ–°æ¨¡å‹
            const geometry = shape.create();
            const material = new THREE.MeshStandardMaterial({
                color: shape.color,
                metalness: 0.3,
                roughness: 0.4
            });
            model = new THREE.Mesh(geometry, material);
            model.position.y = 0.75;
            model.castShadow = true;
            model.receiveShadow = true;
            scene.add(model);

            // æ›´æ–°æ¨¡å‹ä¿¡æ¯å’Œæ ‡ç­¾
            updateModelInfo(model);
            document.getElementById('model-type').textContent = shape.name;
        }

        // åŠ¨ç”»å¾ªç¯
        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate && model) {
                model.rotation.y += 0.01;
            }

            // æ›´æ–°å…¨æ¯é¢æ¿åŠ¨ç”»
            updateHologramAnimation();

            controls.update();
            renderer.render(scene, camera);
        }

        // å“åº”çª—å£å¤§å°å˜åŒ–
        function onWindowResize() {
            const aspect = container.clientWidth / container.clientHeight;
            camera.aspect = aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        }

        // é‡ç½®è§†è§’
        function resetCamera() {
            if (model) {
                const box = new THREE.Box3().setFromObject(model);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
                cameraZ *= 2;

                camera.position.set(0, size.y, cameraZ);
                camera.lookAt(0, size.y / 2, 0);
            }
            controls.reset();
        }

        // äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', onWindowResize);

        document.getElementById('model-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                loadModel(file);
            }
        });

        document.getElementById('auto-rotate-btn').addEventListener('click', () => {
            autoRotate = !autoRotate;
            const btn = document.getElementById('auto-rotate-btn');
            btn.textContent = autoRotate ? 'åœæ­¢æ—‹è½¬' : 'è‡ªåŠ¨æ—‹è½¬';
            btn.classList.toggle('primary');
            btn.classList.toggle('secondary');
        });

        document.getElementById('change-shape-btn').addEventListener('click', changeShape);

        // å…ˆåŠ è½½æ’ä»¶ï¼Œç„¶ååˆå§‹åŒ–
        loadPlugins().then(() => {
            console.log('æ’ä»¶åŠ è½½æˆåŠŸ');
            init();
        }).catch((error) => {
            console.error('æ’ä»¶åŠ è½½å¤±è´¥:', error);
            // å³ä½¿æ’ä»¶åŠ è½½å¤±è´¥ï¼Œä¹Ÿåˆå§‹åŒ–åœºæ™¯ï¼ˆä½¿ç”¨é»˜è®¤çš„ SimpleOrbitControlsï¼‰
            init();
        });
    </script>
</body>
</html>
